use cpal::{
    traits::{DeviceTrait, StreamTrait},
    Device, FromSample, Sample, SizedSample, StreamConfig,
};

use crate::accent::WaveType;
use crate::audio::{get_default_host, get_default_output_config, get_default_output_device};

/// This function creates an audio stream that generates a continuous sine wave at the specified
/// frequency and plays it through the given output device for the specified duration.
///
/// # Arguments
///
/// * `device` - The audio output device to use for playback
/// * `config` - The stream configuration specifying sample rate, channels, etc.
/// * `frequency` - The frequency of the tone in Hz (e.g., 440.0 for A4)
/// * `duration_ms` - The duration to play the tone in milliseconds
///
/// # Type Parameters
///
/// * `T` - The sample type (e.g., f32, i16, u16) that must implement `SizedSample` and `FromSample<f32>`
///
/// # Returns
///
/// Returns `Ok(())` on successful playback, or an error if the audio stream cannot be created or played.
///
/// # Examples
///
/// ```no_run
/// use metronome_rs::tone::play_tone;
/// use cpal::traits::{DeviceTrait, HostTrait};
///
/// let host = cpal::default_host();
/// let device = host.default_output_device().expect("no output device available");
/// let config = device.default_output_config().unwrap();
///
/// play_tone::<f32>(&device, &config.into(), 440.0, 1000).expect("Failed to play tone");
/// ```
pub fn play_tone<T>(
    device: &Device,
    config: &StreamConfig,
    frequency: f32,
    duration_ms: u64,
) -> Result<(), Box<dyn std::error::Error>>
where
    T: SizedSample + FromSample<f32>,
{
    let sample_rate = config.sample_rate.0 as f32;
    let channels = config.channels as usize;

    // Create a sine wave generator for the specified frequency
    let mut sample_clock = 0f32;
    let mut next_value = move || {
        sample_clock = (sample_clock + 1.0) % sample_rate;
        (sample_clock * frequency * 2.0 * std::f32::consts::PI / sample_rate).sin()
    };

    let err_fn = |err| eprintln!("an error occurred on stream: {}", err);

    let stream = device.build_output_stream(
        config,
        move |data: &mut [T], _: &cpal::OutputCallbackInfo| {
            write_data(data, channels, &mut next_value)
        },
        err_fn,
        None,
    )?;
    stream.play()?;

    std::thread::sleep(std::time::Duration::from_millis(duration_ms));

    Ok(())
}

/// Writes audio sample data to the output buffer.
///
/// This function fills the output buffer with samples generated by the provided function,
/// handling multi-channel audio by duplicating the same sample across all channels.
///
/// # Arguments
///
/// * `output` - The output buffer to fill with audio samples
/// * `channels` - The number of audio channels (e.g., 1 for mono, 2 for stereo)
/// * `next_sample` - A function that generates the next audio sample value
///
/// # Type Parameters
///
/// * `T` - The sample type that must implement `Sample` and `FromSample<f32>`
pub fn write_data<T>(output: &mut [T], channels: usize, next_sample: &mut dyn FnMut() -> f32)
where
    T: Sample + FromSample<f32>,
{
    for frame in output.chunks_mut(channels) {
        let value: T = T::from_sample(next_sample());
        for sample in frame.iter_mut() {
            *sample = value;
        }
    }
}

/// Creates a sine wave generator function for a given frequency and sample rate.
///
/// # Arguments
///
/// * `frequency` - The frequency of the sine wave in Hz
/// * `sample_rate` - The sample rate in Hz
///
/// # Returns
///
/// A closure that generates sine wave samples when called
pub fn create_sine_wave_generator(frequency: f32, sample_rate: f32) -> impl FnMut() -> f32 {
    let mut sample_clock = 0f32;
    move || {
        sample_clock = (sample_clock + 1.0) % sample_rate;
        (sample_clock * frequency * 2.0 * std::f32::consts::PI / sample_rate).sin()
    }
}

/// Plays a beep using the default audio device and configuration.
pub fn play_default_beep() -> Result<(), Box<dyn std::error::Error>> {
    let host = get_default_host();
    let device = get_default_output_device(&host)?;
    let config = get_default_output_config(&device)?;

    println!("Default output config: {:?}", config);

    play_beep_with_config(&device, &config.into())
}

/// Plays a beep with the specified device and configuration, automatically handling sample format.
pub fn play_beep_with_config(
    device: &Device,
    config: &StreamConfig,
) -> Result<(), Box<dyn std::error::Error>> {
    match device.default_output_config()?.sample_format() {
        cpal::SampleFormat::F32 => play_tone::<f32>(device, config, 440.0, 1000),
        cpal::SampleFormat::I16 => play_tone::<i16>(device, config, 440.0, 1000),
        cpal::SampleFormat::U16 => play_tone::<u16>(device, config, 440.0, 1000),
        sample_format => {
            println!("Unsupported sample format '{sample_format}', trying f32");
            play_tone::<f32>(device, config, 440.0, 1000)
        }
    }
}

/// Convenience function to play a 440Hz beep for 1 second.
pub fn beep() -> Result<(), Box<dyn std::error::Error>> {
    play_default_beep()
}

/// Convenience function to play a short beep (250ms) at the specified frequency.
pub fn beep_frequency(frequency: f32) -> Result<(), Box<dyn std::error::Error>> {
    let host = get_default_host();
    let device = get_default_output_device(&host)?;
    let config = get_default_output_config(&device)?;

    play_beep_with_config_and_params(&device, &config.into(), frequency, 250)
}

/// Plays a beep with full control over frequency and duration.
pub fn play_beep_with_config_and_params(
    device: &Device,
    config: &StreamConfig,
    frequency: f32,
    duration_ms: u64,
) -> Result<(), Box<dyn std::error::Error>> {
    match device.default_output_config()?.sample_format() {
        cpal::SampleFormat::F32 => play_tone::<f32>(device, config, frequency, duration_ms),
        cpal::SampleFormat::I16 => play_tone::<i16>(device, config, frequency, duration_ms),
        cpal::SampleFormat::U16 => play_tone::<u16>(device, config, frequency, duration_ms),
        sample_format => {
            println!("Unsupported sample format '{sample_format}', trying f32");
            play_tone::<f32>(device, config, frequency, duration_ms)
        }
    }
}

/// Plays a tone with a specified wave type.
pub fn play_tone_with_wave_type<T>(
    device: &Device,
    config: &StreamConfig,
    frequency: f32,
    duration_ms: u64,
    wave_type: WaveType,
) -> Result<(), Box<dyn std::error::Error>>
where
    T: SizedSample + FromSample<f32>,
{
    let sample_rate = config.sample_rate.0 as f32;
    let channels = config.channels as usize;

    // Create a wave generator for the specified frequency and wave type
    let mut sample_clock = 0f32;
    let mut next_value = move || {
        sample_clock = (sample_clock + 1.0) % sample_rate;
        let phase = sample_clock * frequency * 2.0 * std::f32::consts::PI / sample_rate;

        match wave_type {
            WaveType::Sine => phase.sin(),
            WaveType::Square => {
                if phase.sin() >= 0.0 {
                    1.0
                } else {
                    -1.0
                }
            }
            WaveType::Sawtooth => {
                let normalized_phase = (phase / (2.0 * std::f32::consts::PI)) % 1.0;
                2.0 * normalized_phase - 1.0
            }
            WaveType::Triangle => {
                let normalized_phase = (phase / (2.0 * std::f32::consts::PI)) % 1.0;
                if normalized_phase < 0.5 {
                    4.0 * normalized_phase - 1.0
                } else {
                    3.0 - 4.0 * normalized_phase
                }
            }
        }
    };

    let err_fn = |err| eprintln!("an error occurred on stream: {}", err);

    let stream = device.build_output_stream(
        config,
        move |data: &mut [T], _: &cpal::OutputCallbackInfo| {
            write_data(data, channels, &mut next_value)
        },
        err_fn,
        None,
    )?;
    stream.play()?;

    std::thread::sleep(std::time::Duration::from_millis(duration_ms));

    Ok(())
}

/// Plays a beep with full control over frequency, duration, and wave type.
pub fn play_beep_with_wave_type(
    device: &Device,
    config: &StreamConfig,
    frequency: f32,
    duration_ms: u64,
    wave_type: WaveType,
) -> Result<(), Box<dyn std::error::Error>> {
    match device.default_output_config()?.sample_format() {
        cpal::SampleFormat::F32 => {
            play_tone_with_wave_type::<f32>(device, config, frequency, duration_ms, wave_type)
        }
        cpal::SampleFormat::I16 => {
            play_tone_with_wave_type::<i16>(device, config, frequency, duration_ms, wave_type)
        }
        cpal::SampleFormat::U16 => {
            play_tone_with_wave_type::<u16>(device, config, frequency, duration_ms, wave_type)
        }
        sample_format => {
            println!("Unsupported sample format '{sample_format}', trying f32");
            play_tone_with_wave_type::<f32>(device, config, frequency, duration_ms, wave_type)
        }
    }
}

/// Plays a beep with full control over frequency, duration, wave type, and volume.
pub fn play_beep_with_wave_type_and_volume(
    device: &Device,
    config: &StreamConfig,
    frequency: f32,
    duration_ms: u64,
    wave_type: WaveType,
    volume: f32,
) -> Result<(), Box<dyn std::error::Error>> {
    match device.default_output_config()?.sample_format() {
        cpal::SampleFormat::F32 => play_tone_with_wave_type_and_volume::<f32>(
            device,
            config,
            frequency,
            duration_ms,
            wave_type,
            volume,
        ),
        cpal::SampleFormat::I16 => play_tone_with_wave_type_and_volume::<i16>(
            device,
            config,
            frequency,
            duration_ms,
            wave_type,
            volume,
        ),
        cpal::SampleFormat::U16 => play_tone_with_wave_type_and_volume::<u16>(
            device,
            config,
            frequency,
            duration_ms,
            wave_type,
            volume,
        ),
        sample_format => {
            println!("Unsupported sample format '{sample_format}', trying f32");
            play_tone_with_wave_type_and_volume::<f32>(
                device,
                config,
                frequency,
                duration_ms,
                wave_type,
                volume,
            )
        }
    }
}

/// Plays a tone with a specified wave type and volume.
pub fn play_tone_with_wave_type_and_volume<T>(
    device: &Device,
    config: &StreamConfig,
    frequency: f32,
    duration_ms: u64,
    wave_type: WaveType,
    volume: f32,
) -> Result<(), Box<dyn std::error::Error>>
where
    T: SizedSample + FromSample<f32>,
{
    let sample_rate = config.sample_rate.0 as f32;
    let channels = config.channels as usize;
    let volume = volume.clamp(0.0, 1.0); // Ensure volume is between 0 and 1

    // Create a wave generator for the specified frequency and wave type
    let mut sample_clock = 0f32;
    let mut next_value = move || {
        sample_clock = (sample_clock + 1.0) % sample_rate;
        let phase = sample_clock * frequency * 2.0 * std::f32::consts::PI / sample_rate;

        let base_amplitude = match wave_type {
            WaveType::Sine => phase.sin(),
            WaveType::Square => {
                if phase.sin() >= 0.0 {
                    1.0
                } else {
                    -1.0
                }
            }
            WaveType::Sawtooth => {
                let normalized_phase = (phase / (2.0 * std::f32::consts::PI)) % 1.0;
                2.0 * normalized_phase - 1.0
            }
            WaveType::Triangle => {
                let normalized_phase = (phase / (2.0 * std::f32::consts::PI)) % 1.0;
                if normalized_phase < 0.5 {
                    4.0 * normalized_phase - 1.0
                } else {
                    3.0 - 4.0 * normalized_phase
                }
            }
        };

        base_amplitude * volume // Apply volume scaling
    };

    let err_fn = |err| eprintln!("an error occurred on stream: {}", err);

    let stream = device.build_output_stream(
        config,
        move |data: &mut [T], _: &cpal::OutputCallbackInfo| {
            write_data(data, channels, &mut next_value)
        },
        err_fn,
        None,
    )?;
    stream.play()?;

    std::thread::sleep(std::time::Duration::from_millis(duration_ms));

    Ok(())
}
